import { Test, TestingModule } from '@nestjs/testing';
import { BooksRepository } from './books.repository';
import { BooksService } from './books.service';
import { CreateBookDto } from './dto/create-book.dto';
import { UpdateBookDto } from './dto/update-book.dto';
describe('BooksService', () => {  let service: BooksService;  let repository: BooksRepository;  const mockBook = {    id: '1',    name: 'Test Book',    author: 'Test Author',    description: 'Test Description',    cover: 'http://example.com/image.jpg',    createdAt: new Date(),    updatedAt: new Date(),  };  const mockBooksRepository = {    createBook: jest.fn(),    findAllBooks: jest.fn(),    findBookById: jest.fn(),    updateBook: jest.fn(),    deleteBook: jest.fn(),  };  beforeEach(async () => {    const module: TestingModule = await Test.createTestingModule({      providers: [        BooksService,        {          provide: BooksRepository,          useValue: mockBooksRepository,        },      ],    }).compile();    service = module.get<BooksService>(BooksService);    repository = module.get<BooksRepository>(BooksRepository);  });  afterEach(() => {    jest.clearAllMocks();  });  it('should be defined', () => {    expect(service).toBeDefined();  });  describe('create', () => {    it('should create a new book', async () => {      const createBookDto: CreateBookDto = {        name: 'New Book',        author: 'New Author',        description: 'New Description',        cover: 'http://example.com/new-image.jpg',      };      mockBooksRepository.createBook.mockResolvedValue(mockBook);      const result = await service.create(createBookDto);      expect(result).toEqual(mockBook);      expect(mockBooksRepository.createBook).toHaveBeenCalledWith(createBookDto);    });  });  describe('findAll', () => {    it('should return paginated books', async () => {      const mockPaginatedResult = {        data: [mockBook],        total: 1,        page: 1,        limit: 10,        totalPages: 1,      };      mockBooksRepository.findAllBooks.mockResolvedValue(mockPaginatedResult);      const result = await service.findAll(1, 10);      expect(result).toEqual(mockPaginatedResult);      expect(mockBooksRepository.findAllBooks).toHaveBeenCalledWith({        skip: 0,        take: 10,      });    });  });  describe('findOne', () => {    it('should return a book by id', async () => {      mockBooksRepository.findBookById.mockResolvedValue(mockBook);      const result = await service.findOne('1');      expect(result).toEqual(mockBook);      expect(mockBooksRepository.findBookById).toHaveBeenCalledWith('1');    });    it('should throw NotFoundException if book not found', async () => {      mockBooksRepository.findBookById.mockResolvedValue(null);      await expect(service.findOne('999')).rejects.toThrow();      expect(mockBooksRepository.findBookById).toHaveBeenCalledWith('999');    });  });  describe('update', () => {    it('should update a book', async () => {      const updateBookDto: UpdateBookDto = {        name: 'Updated Book',      };      const updatedBook = { ...mockBook, ...updateBookDto };      mockBooksRepository.findBookById.mockResolvedValue(mockBook);      mockBooksRepository.updateBook.mockResolvedValue(updatedBook);      const result = await service.update('1', updateBookDto);      expect(result).toEqual(updatedBook);      expect(mockBooksRepository.findBookById).toHaveBeenCalledWith('1');      expect(mockBooksRepository.updateBook).toHaveBeenCalledWith('1', updateBookDto);    });    it('should throw NotFoundException if book not found', async () => {      const updateBookDto: UpdateBookDto = {        name: 'Updated Book',      };      mockBooksRepository.findBookById.mockResolvedValue(null);      await expect(service.update('999', updateBookDto)).rejects.toThrow();      expect(mockBooksRepository.findBookById).toHaveBeenCalledWith('999');    });  });  describe('remove', () => {    it('should remove a book', async () => {      const deletedBook = { ...mockBook, deletedAt: new Date() };      mockBooksRepository.findBookById.mockResolvedValue(mockBook);      mockBooksRepository.deleteBook.mockResolvedValue(deletedBook);      const result = await service.remove('1');      expect(result).toEqual(deletedBook);      expect(mockBooksRepository.findBookById).toHaveBeenCalledWith('1');      expect(mockBooksRepository.deleteBook).toHaveBeenCalledWith('1');    });    it('should throw NotFoundException if book not found', async () => {      mockBooksRepository.findBookById.mockResolvedValue(null);      await expect(service.remove('999')).rejects.toThrow();      expect(mockBooksRepository.findBookById).toHaveBeenCalledWith('999');    });  });});